package main

import (
	"flag"
	"fmt"
	"os"
	"strings"

	"github.com/hashicorp/terraform/plans"
	"github.com/hashicorp/terraform/plans/planfile"
	"github.com/jaysonsantos/terraform-plan-importer/importer"
	_ "github.com/jaysonsantos/terraform-plan-importer/importer/aws"
	"github.com/zclconf/go-cty/cty"
)

const allImporters = "all-importers"

func main() {
	Main()
}

func Main() {
	state := flag.String("state", "", "State generated by terraform")
	flag.Parse()

	if *state == "" {
		_, _ = fmt.Fprintln(os.Stderr, "you must provide a state file")
		flag.Usage()
		os.Exit(1)
	}

	_, _ = fmt.Fprintln(os.Stderr, "reading state")
	plan := parsePlan(state)

	selectedImporters := filterImporters()
	initializeImporters(selectedImporters)

	importPlans(plan, selectedImporters)
	fmt.Fprintf(os.Stderr, "done")
}

func parsePlan(state *string) *plans.Plan {
	planFile, err := planfile.Open(*state)
	if err != nil {
		panic(fmt.Sprintf("%v", err))
	}
	plan, err := planFile.ReadPlan()
	if err != nil {
		panic(fmt.Sprintf("%v", err))
	}
	return plan
}

func importPlans(plan *plans.Plan, selectedImporters []importer.Importer) {
	for _, resource := range plan.Changes.Resources {
		if resource.Action != plans.Create {
			continue
		}

		impliedType, err := resource.After.ImpliedType()
		if err != nil {
			panic(err)
		}
		resourceData, err := resource.After.Decode(impliedType)
		if err != nil {
			panic(err)
		}
		resourceParameters := resourceData.AsValueMap()
		possibleName := resourceParameters["name"]

		var name string
		if possibleName.Type() == cty.String {
			name = possibleName.AsString()
		}

		var resourceProvider = resource.ProviderAddr.ProviderConfig.Type.Type
		var resourceFullName string
		if resource.Addr.Module.String() == "" {
			resourceFullName = resource.Addr.Resource.String()
		} else {
			resourceFullName = fmt.Sprintf("%s.%s", resource.Addr.Module, resource.Addr.Resource)
		}

		var resourceToImport string
		for _, imp := range selectedImporters {
			if resourceProvider != imp.ImporterName() {
				continue
			}
			resourceToImport, err = imp.GetImportName(resource.Addr.Resource.Resource.Type, name, resourceParameters)
			if resourceToImport != "" {
				break
			}
			fmt.Fprintf(os.Stderr, "skipping importer %s on resource %s because of an error %v\n",
				imp.ImporterName(), resourceFullName, err)
		}

		if resourceToImport == "" {
			continue
		}
		fmt.Printf("terraform import '%s' '%s'\n", resourceFullName, resourceToImport)
	}
}

func validateImporters(selectedImporters []importer.Importer) {
	if selectedImporters == nil || len(selectedImporters) == 0 {
		var importerNames []string
		for _, i := range importer.Importers {
			importerNames = append(importerNames, i.ImporterName())
		}

		fmt.Fprintf(os.Stderr, "no importer selected, specify %v or one of %v", allImporters, strings.Join(importerNames, ", "))
		os.Exit(1)
	}
}

func filterImporters() []importer.Importer {
	var selectedImporters []importer.Importer
	for _, possibleImporter := range flag.Args() {
		if possibleImporter == allImporters {
			selectedImporters = importer.Importers
			break
		}
		var selectedImporter importer.Importer
		for _, tempImporter := range importer.Importers {
			if tempImporter.ImporterName() == possibleImporter {
				selectedImporter = tempImporter
			}
		}
		if selectedImporter == nil {
			fmt.Fprintf(os.Stderr, "importer not found %v\n", possibleImporter)
			os.Exit(1)
		}
		selectedImporters = append(selectedImporters, selectedImporter)
	}

	validateImporters(selectedImporters)
	return selectedImporters
}

func initializeImporters(selectedImporters []importer.Importer) {
	for _, selectedImporter := range selectedImporters {
		fmt.Fprintf(os.Stderr, "initializing importer %v\n", selectedImporter.ImporterName())
		err := selectedImporter.Init()
		if err != nil {
			panic(err)
		}
	}
}
